---
interface Props {
  text: string;
  class?: string;
}

const { text, class: className = "" } = Astro.props;

const words = text.split(' ');
---

<div class={`scroll-reveal-text ${className}`} data-scroll-text>
  {words.map((word) => (
    <span class="word">
      {word.split('').map((char) => (
        <span class="char">{char}</span>
      ))}
      <span class="char"> </span>
    </span>
  ))}
</div>

<style>
  .scroll-reveal-text {
    font-size: 2.5rem;
    line-height: 1.4;
    font-weight: 400;
  }

  .word {
    display: inline;
  }

  .char {
    opacity: 0.2;
    transition: opacity 0.4s ease-out;
  }

  @media (max-width: 768px) {
    .scroll-reveal-text {
      font-size: 1.5rem;
    }
  }
</style>

<script>
  function initScrollReveal() {
    const textElements = document.querySelectorAll('[data-scroll-text]');
    
    textElements.forEach((element) => {
      const chars = Array.from(element.querySelectorAll('.char'));
      let isActive = false;

      function updateOpacity() {
        const rect = element.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        const windowCenter = windowHeight / 2;
        
        // Calcular cu치nto del elemento est치 visible
        const elementCenter = rect.top + rect.height / 2;
        const distanceFromCenter = windowCenter - elementCenter;
        
        // Progreso: 0 cuando est치 fuera de vista, 1 cuando est치 centrado
        const progress = Math.max(0, Math.min(1, (distanceFromCenter + windowHeight / 2) / (windowHeight + rect.height)));
        
        // Revelar caracteres progresivamente
        chars.forEach((char, index) => {
          const charProgress = index / chars.length;
          const revealThreshold = charProgress * 0.5; // 80% del progreso total
          
          if (progress >= revealThreshold) {
            const charOpacity = Math.min(1, (progress - revealThreshold) / 0.2 + 0.2);
            (char as HTMLElement).style.opacity = charOpacity.toString();
          } else {
            (char as HTMLElement).style.opacity = '0.2';
          }
        });
      }

      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && !isActive) {
              isActive = true;
              updateOpacity();
              window.addEventListener('scroll', updateOpacity, { passive: true });
            } else if (!entry.isIntersecting && isActive) {
              isActive = false;
              window.removeEventListener('scroll', updateOpacity);
            }
          });
        },
        {
          threshold: 0,
          rootMargin: '100px 0px 100px 0px'
        }
      );

      observer.observe(element);
      
      // Actualizar una vez al cargar
      updateOpacity();
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initScrollReveal);
  } else {
    initScrollReveal();
  }

  document.addEventListener('astro:page-load', initScrollReveal);
</script>